#!/bin/bash

# Variable
## General
url="http://www.google.com/search?q="
filter="&filter=0"
start="&start="
userAgent="User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0"
version="1.2.2"

## Effects

# tput: This is a command-line utility in Unix-like operating systems (including Linux and macOS)
#       that allows you to interact with the terminal capabilities database. It is often used to
#       query and set terminal attributes, such as text color, font style, and cursor positioning.

# bold: This is an argument passed to the tput command. It specifies that we want to retrieve the
#       control sequence that sets the text to be displayed in bold.

cBold=$(tput bold)
cRedBold=$(
    tput setaf 1
    tput bold
)
cNormal=$(tput sgr0) # No Color, No Bold

# Test Statement
# echo "${cBold} This text is bold.${cNormal}"

# Functions
## Usage
function usage {
    echo -e "Usage:
    \t-h                                               Displays this help message
    \t-w <DICTIONARY|PATH|FILE>                Specify a Dictionary, path or file
    \t-e <EXTENSION>                           Specify comma-separated extensions
    \t-t <TARGET>                                  Specify a DOMAIN or IP address
    \t-p <PAGES>                                      Specify the number of PAGES
    \t-x <EXCLUSIONS>                                EXCLUDES targets in searches
    \t-d <DELAY>                                Delay in seconds between requests
    \t-s                                 Lists subdomains of the specified domain
    \t-c <TEXT>                 Specify revelant content in comma-separated files
    \t-o <FILENAME>                   Export the results to a file (results only)
    "
    echo -e "
    \b\b\b\bExamples:
        StealthSearch -t site.com -e pdf,doc,bak
        StealthSearch -t site.com -e pdf -p 2
        StealthSearch -t www.site.com -e extensionslist.txt
        StealthSearch -t www.site.com -w config.php,admin,/images/
        StealthSearch -t wsite.com -w wp-admin -p 1
        StealthSearch -t site.com -w wordlist.txt
        StealthSearch -t site.com -w login.html -x dev.site.com
        StealthSearch -t site.com -w admin.html -x exclusion_list.txt
        StealthSearch -t site.com -s -p 10 -d 5 -o StealthSearch-subdomains.txt
        StealthSearch -t site.com -c P@ssw0rd!
    "
    exit 0
}
## Checking parameters

# if [[ ${OPTARG} =~ ^- ]]; then: This is an if statement that checks whether the value of the
# OPTARG variable starts with a hyphen (-). OPTARG is a special variable used with the getopts
# command to hold the value of the currently parsed option's argument. The `=~` operator is used
# for regular expression matching. The regular expression `^-` matches a string that starts with
# a hyphen.

# If the condition is true (meaning the option's argument starts with a hyphen), it means that
# the parameter is not valid because it's likely a new option and not a proper argument for
# the previous option.

## Checking Parameters
function parametersCheck() {
    if [[ ${OPTARG} =~ ^- ]]; then # here ; represents the end of if condition.
        showError
    fi
}
## Show Banner
function banner() {
    echo "
    ╔═╗┌┬┐┌─┐┌─┐┬ ┌┬┐┬ ┬╔═╗┌─┐┌─┐┬─┐┌─┐┬ ┬
    ╚═╗ │ ├┤ ├─┤│  │ ├─┤╚═╗├┤ ├─┤├┬┘│  ├─┤
    ╚═╝ ┴ └─┘┴ ┴┴─┘┴ ┴ ┴╚═╝└─┘┴ ┴┴└─└─┘┴ ┴
    "
}

## Show Error
function showError() {
    echo -e "\n${cRedBold}[!]${cNormal} Error, missing or invalid argument.\n"
    usage
}

function notFound() {
    # Checking temporal ban from Google
    checkBan

    if [[ -n "$extension" ]]; then
        echo -e "\nSorry, no results found for ${cBold}${extension}${cNormal}.\n"
    elif [[ -n "$dictionary" ]]; then
        echo -e "\n Sorry, no results found."
    elif [[ -n "$subdomain" ]]; then
        echo -e "\nSorry, no results found for ${cBold}${extension}${cNormal}.\n"
    elif [[ -n "$contents" ]]; then
        echo -e "\n Sorry, no results found."
    fi
}

## Show content in files
function showConentInFile() {
    if [[ -n "$contents" ]]; then
        echo -e "Files found containing: ${cBold}${contents}${cNormal}"
    fi
}

## Exit StealthSearch

# 'trap ctrl_c INT' is setting up a handler to execute the ctrl_c function when the
# script receives the INT signal, which is generated by the user pressing Ctrl+C.
trap ctrl_c INT

function ctrl_c() {
    echo -e "\n${cRedBold}[!]${cNormal} Exiting StealthSearch...\n"
    exit 1
}

## Google Ban Check
function checkBan() {
    checkBanStatus=$(curl -s -H "$userAgent" "${url}site:${target}${filter}${start}${pageNum}")
    if [[ ${checkBanStatus} =~ "The document has moved" ]]; then
        echo -e "\n${cRedBold}[!]${cNormal} Oops... Looks like Google has temporariliy blocked your IP address.\n"
        exit 1
    fi
}

## URL Decode

# series of sed (stream editor) substitution commands that are used to replace URL-encoded
# characters with their corresponding regular characters in a text stream

function urlDecode() {
    sed 's/%3F/?/g;s/%3D/=/g;s/%20/ /g;s/%2520/ /g;s/%21/!/g;s/%23/#/g;s/%24/\$/g;s/%25/\&/g;s/%2B/+/g;s/%26/&/g;s/%3A/:/g;s/%2E/./g;s/%2F/\//g;s/%5F/_/g;s/%28/(/g;s/%29/)/g;s/%26/\&/g'
}
## Exclusions
# site:google.com -cloud.google.com -fonts.google.com
function exclusionCheck() {
    # Need variables
    excludeTargets="-site:"

    # Checking file exist
    if [[ -f "$exclusions" ]]; then
        for exclusion in $(cat "$exclusions"); do
            if [[ $multi -eq 1 ]]; then
                # site:google.com -site:-workspace.google.com -cloud.google.com
                # Here we have + because of the space we need between the exclusions
                exclusion="+-${exclusion}"
            fi
            excludeTargets="$excludeTargets${exclusion}"
            multi=1 # On Multi-Liner
        done
    elif [[ "$exclusions" =~ "," ]]; then
        excludeTargetsList=$(echo "$exclusions" | sed 's/,/ /g')
        for exclusion in $excludeTargetsList; do
            if [[ $multi -eq 1 ]]; then
                exclusion="+-${exclusion}"
            fi
            excludeTargets="$excludeTargets${exclusion}"
            multi=1 # On Multi-Liner
        done
    else
        # site:google.com -site:workspace.google.com
        excludeTargets="${excludeTargets}${exclusions}"
    fi
}

## Search the contents of files
function contentsCheck() {
    # Needs variables
    inFile="infile:\""

    # Checking file exist
    if [[ -f "$contents" ]]; then
        for content in $(cat "$contents"); do
            if [[ $multi -eq 1 ]]; then
                # The "||" operator is used to combine multiple search terms or conditions, indicating
                # that either one or the other (or both) should be present in the search results.
                content="+||+\"${content}\""
            fi
            inFile="$inFile${content}"
            multi = 1
        done
    elif [[ "$contents" =~ "," ]]; then
        contentsList=$(echo "$contents" | sed 's/,/"+||+"/g')
        inFile="$inFile${contentsList}\""
    else
        inFile="$inFile${contents}\""
    fi
}

## Search words in URL
function inurlCheck() {
    # Checking file exist
    if [[ -f "$dictionary" ]]; then
        for word in $(cat "dictionary"); do
            if [[ $multi -eq 1 ]]; then
                word="+|+${word}"
            fi
            inUrl="$inUrl${word}"
            multi=1
        done
    elif [[ "$dictionary" =~ "," ]]; then
        dictionaryList=$(echo $dictionary | sed 's/,/+|+/g')
        inUrl="$inUrl${dictionaryList}"
    else
        inUrl="${dictionary}"
    fi
}

## Calculate sending requests
function calcRequests() {
    # -z: checks for empty string | -eq 0: checks if val of pages is 0
    if [[ -z $pages ]] || [[ $pages -eq 0 ]]; then
        return $totalRequests
    else
        let totalRequests=$totalRequests*$pages
        return $totalRequests
    fi
}

## Delay Control
function delayControl() {
    # Checking
    if [[ -n "$delay" ]]; then
        sleep "$delay"s
    else
        sleep 0s
    fi
}

## Request
function requestRun() {
    # Reset variables
    requestStorage=0
    page=0

    # Checking pages value
    if [[ -z $pages ]] || [[ $pages -eq 0 ]]; then
        pages=1
    fi

    while [[ $page -lt $pages ]]; do
        # https://www.geeksforgeeks.org/let-command-in-linux-with-examples/
        let pageNum=$page*10

        if [[ -n "$extension" ]]; then
            # https://www.google.com/search?q=site:example filetype:pdf document site:-unwanted.com content:important start=0 10
            request=$(curl -s -H "$userAgent" "${url}site:${target}+filetype:${extension}+${inFile}+${excludeTargets}${filter}${start}${pageNum}" | grep -oE '(http|https)://[a-zA-Z0-9./?=_%:-]*' | grep -i "${target}" | grep -viE "gogole" | grep -i "${extension}" | urlDecode | sort -u)
        elif [[ -n "$dictionary" ]]; then
            # https://www.google.com/search?q=site:examplewebsite -exclude1 -exclude2 inurl:"specificstring"&filterparam=value&start=0&page=1
            request=$(curl -s -H "$userAgent" "${url}site:${target}+${excludeTargets}+inurl:\"${inUrl}\"${filter}${start}${pageNum}" | grep -oE '(http|https)://[a-zA-Z0-9./?=_%:-]*' | grep -i "${target}/" | grep -viE "google" | urlDecode | sort -u)
        elif [[ -n "$subdomain" ]]; then
            # https://www.google.com/search?q=site:*.example -site:www.example&filter=some_criteria&start=10&page=2
            request=$(curl -s -H "$userAgent" "${url}site:*.${target}+-site:www.${target}${filter}${start}${pageNum}" | grep -oE "(http|https)://[a-zA-Z0-9./?=_%:-]*${target}" | sort -u)
        elif [[ -n "$contents" ]]; then
            request=$(curl -s -H "$userAgent" "${url}site:${target}+${inFile}+${excludeTargets}${filter}${start}${pageNum}" | grep -oE "(http|https)://[a-zA-Z0-9./?=_%:-]*" | grep -i "${target}/" | grep -viE "google" | urlDecode | sort -u)
        fi
        if [[ -z "$request" ]]; then
            break
        fi

        # Request Storage
        requestStorage+="$request"

        # Pages Incremental
        ((pages++))

        # Delay Control
        delayControl
    done
}

## StealthSearch Dictionary Attack
function dictionaryAttack() {
    echo -e "\nTarget: ${cBold}${target}${cNormal}"

    # Send Request
    requestRun

    # Show Information
    if [[ -n "$requestStorage" ]]; then
        str="Directories and files found from: ${cBold}${dictionary}${cNormal}"
        n=${#str}
        ((n += 1))
        chr="="
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo -e "${str}"
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo "$requestStorage" | sort -u

        # Output file
        if [[ -n "$outputFile" ]]; then
            outputFile "$requestStorage" "$outputFile"
        fi
    else
        notFound
    fi
}

## StealthSearch Extension Attack
function extensionAttack() {
    echo -e "\nTarget: ${cBold}${target}${cNormal}"

    # Checking file exist
    if [[ -f "$extension" ]]; then
        # Count lines
        # The awk command is used for text processing. In this case, 
        # it's used to extract the first field (the number of lines) from the output of wc
        totalRequests=$(wc -l "${extension}" | awk '{printf $1}')

        # Calculate
        calcRequests

        echo -e "Total requests: ${totalRequests}"

        for extension in $(cat "$extension"); do
            # Send request
            requestRun

            # Show information
            if [[ -n "$requestStorage" ]]; then
                str="Extension: ${cBold}${extension}${cNormal}" 
                n=${#str}
                ((n += 1))
                chr="="
                echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
                echo -e "${str}"
                showConentInFile
                echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
                echo "$requestStorage"

                # Output file
                if [[ -n "$outputFile" ]]; then
                    outputFile "$requestStorage" "$outputFile"
                fi
            else
                notFound
            fi
        done

        # Close Script
        exit 1
    
    # Checking various extensions
    elif [[ "$extension" =~ "," ]]; then
        extensionslist=$(echo "$extension" | sed 's/,/ /g')

        for extension in $extensionslist; do
            # Send Request
            requestRun

            # Show Information
            if [[ -n "$requestStorage" ]]; then
                str="Extension: ${cBold}${extension}${cNormal}" 
                n=${#str}
                ((n += 1))
                chr="="
                echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
                echo -e "${str}"
                showConentInFile
                echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
                echo "$requestStorage"

                # Output file
                if [[ -n "$outputFile" ]]; then
                    outputFile "$requestStorage" "$outputFile"
                fi
            else
                notFound
            fi
        done

        # Close script
        exit 1
    else
        # Send Request
        requestRun
    
        # Show information
        if [[  -n "$requestStorage" ]]; then
            str=echo -e "Extension: ${cBold}${extension}${cNormal}"
            n=${#str}
            ((n += 1))
            chr="="
            echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
            echo -e "${str}"
            showConentInFile
            echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
            echo "$requestStorage"

            # Output file
            if [[ -n "$outputFile" ]]; then
                outputFile "$requestStorage" "$outputFile"
            fi
        else
            notFound
        fi
    fi
}

## StealthSearch Subdomains Attack
function subdomainAttack() {
    echo -e "\nTarget: ${cBold}${target}${cNormal}"

    # Send request
    requestRun

    # Show information
    if [[ -n "$requestStorage" ]]; then
        str="Subdomains Found:"
        n=${#str}
        ((n += 1))
        chr="="
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo -e "${str}"
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo "$requestStorage" | sort -u

        # Output file
        if [[ -n "$outputFile" ]]; then
            outputFile "$requestStorage" "$outputFile"
        fi
    else
        notFound
    fi
}


## StealthSearch Contents Attack
function contentsAttack() {
    echo -e "\nTarget: ${bold}${target}${cNormal}"

    # Send Request
    requestRun

    # Show information
    if [[ -n "$requestStorage" ]]; then
        str="Files found containing: ${contents}"
        n=${#str}
        ((n += 1))
        chr="="
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo -e "${str}"
        echo -e "$(printf "%0.s${chr}" $(seq ${n}))"
        echo "$requestStorage" | sort -u

        # Output file
        if [[ -n "$outputFile" ]]; then
            outputFile "$requestStorage" "$outputFile"
        fi
    else
        notFound
    fi
        
}

function outputFile() {
    echo "$requestStorage" >> $outputFile
}

# Script Execute

## Options

# The line you provided is a part of a Bash script and is used to process command-line options
# using the getopts command. The getopts command is used to parse command-line options and their
# arguments in a script.

# (while getopts :p:x:c:d:w:e:o:t:sh option;): This line starts a while loop that uses the getopts
# command to parse command-line options. The colon (:) following the getopts command indicates
# that some of the options require an argument. The letters following the colon are the valid
# options that the script can handle, each followed by a colon if an argument is expected.
# The loop iterates over the command-line arguments and processes the options and their arguments.

# option: This is a variable that will hold the current option being processed by getopts.

# -p: This is an option that expects an argument. The argument will be stored in the variable OPTARG

while getopts :p:x:c:d:w:e:o:t:sh option; do
    case ${option} in
    h)
        banner
        usage
        break
        exit 1
        ;;
    p)
        parametersCheck
        pages=${OPTARG}
        ;;
    x)
        parametersCheck
        exclusions=${OPTARG}
        exclusionsCheck
        ;;
    c)
        parametersCheck
        contents=${OPTARG}
        contentsCheck
        ;;
    d)
        parametersCheck
        delay=${OPTARG}
        ;;
    w)
        parametersCheck
        dictionary=${OPTARG}
        inurlCheck
        ;;
    e)
        parametersCheck
        extension=${OPTARG}
        ;;
    o)
        parametersCheck
        outputFile=${OPTARG}
        ;;
    t)
        parametersCheck
        target=${OPTARG}
        ;;
    s)
        parametersCheck
        subdomain=on
        ;;
    *)
        banner
        showError
        ;;
    esac
done

## Continue
banner

if [[ -n "$target" ]] && [[ -n "$dictionary" ]] && [[ -z "$subdomain" ]] && [[ -z "$extension" ]] && [[ -z "$contents" ]]; then
    dictionaryAttack
    exit 1

elif [[ -n "$target" ]] && [[ -n "$extension" ]] && [[ -z $subdomain ]] && [[ -z $dictionary ]]; then
    extensionAttack
    exit 1

elif [[ -n "$target" ]] && [[ -n "$subdomain" ]] && [[ -z $extension ]] && [[ -z $dictionary ]] && [[ -z "$contents" ]]; then
    subdomainAttack
    exit 1

elif [[ -n "$target" ]] && [[ -n "$contents" ]] && [[ -z $subdomain ]] && [[ -z $dictionary ]]; then
    contentsAttack
    exit 1
else
    showError
fi
